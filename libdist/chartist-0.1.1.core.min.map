{"version":3,"file":"chartist-0.1.1.core.min.js","sources":["../source/scripts/chartist.core.js"],"names":["document","window","undefined","Chartist","version","noop","n","alphaNumerate","String","fromCharCode","extend","target","source","prop","each","array","callback","i","length","value","call","getHeight","svgElement","clientHeight","Math","round","getBBox","height","parentNode","getWidth","clientWidth","width","createPaper","query","paper","container","nodeType","querySelector","__chartistPaper","attr","clear","Snap","appendChild","node","getDataArray","data","series","normalizeDataArray","dataArray","j","orderOfMagnitude","floor","log","abs","LN10","projectLength","bounds","options","availableHeight","getAvailableHeight","range","chartPadding","axisX","offset","getHighLow","highLow","high","Number","MIN_VALUE","low","MAX_VALUE","getBounds","newMin","newMax","valueRange","oom","min","pow","max","ceil","step","numberOfSteps","axisY","scaleMinSpace","values","push","calculateLabelOffset","labelClass","labelInterpolationFnc","offsetFnc","interpolated","label","text","setAttribute","remove","interpolateData","index","interpolatedValue","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","PI","x","cos","y","sin","createChartRect","xAxisOffset","yAxisOffset","x1","y1","x2","y2","this","createXAxis","chartRect","grid","labels","pos","showGrid","line","classNames","horizontal","join","add","showLabel","createYAxis","vertical","labelAlign","text-anchor","projectPoint","optionsProvider","defaultOptions","responsiveOptions","optionsChangedCallbackFnc","applyOptions","currentOptions","baseOptions","mql","matchMedia","matches","mediaQueryListeners","addListener"],"mappings":"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","sourcesContent":["(function (document, window, undefined) {\n  'use strict';\n\n  // Export chartist namespace\n  var Chartist = window.Chartist = window.Chartist || {};\n\n  Chartist.version = '0.0.3';\n\n  // Helps to simplify functional style code\n  Chartist.noop = function (n) {\n    return n;\n  };\n\n  // Generates a-z from number\n  Chartist.alphaNumerate = function (n) {\n    // Limit to a-z\n    return String.fromCharCode(97 + n % 26);\n  };\n\n  // Simple recursive object extend\n  Chartist.extend = function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      if (typeof source[prop] === 'object') {\n        target[prop] = Chartist.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  };\n\n  // Simple array each function\n  // TODO: Use Array forEach as browser support allows (IE 9+)\n  Chartist.each = function (array, callback) {\n    for (var i = 0; i < array.length; i++) {\n      var value = callback.call(array[i], i, array[i]);\n\n      if (value === false) {\n        break;\n      }\n    }\n  };\n\n  // Get element height / width with fallback to svg BoundingBox or parent container dimensions\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=530985\n  Chartist.getHeight = function (svgElement) {\n    return svgElement.clientHeight || Math.round(svgElement.getBBox().height) || svgElement.parentNode.clientHeight;\n  };\n\n  Chartist.getWidth = function (svgElement) {\n    return svgElement.clientWidth || Math.round(svgElement.getBBox().width) || svgElement.parentNode.clientWidth;\n  };\n\n  // Create Chartist container and instantiate snap paper\n  Chartist.createPaper = function (query, width, height) {\n    // Get dom object from query or if already dom object just use it\n    var container = query.nodeType ? query : document.querySelector(query),\n      paper;\n\n    // If container was not found we throw up\n    if (!container) {\n      throw 'Container node with selector \"' + query + '\" not found';\n    }\n\n    // If already contains paper we clear it, set width / height and return\n    if (container.__chartistPaper !== undefined) {\n      paper = container.__chartistPaper.attr({\n        width: width || '100%',\n        height: height || '100%'\n      });\n      // Clear the paper if its already used before so we start fresh\n      paper.clear();\n\n    } else {\n      // Create Snap paper with width and height or use 100% as default\n      paper = Snap(width || '100%', height || '100%');\n      if (!paper) {\n        throw 'Could not instantiate Snap.js!';\n      }\n      // Append the snap SVG to our container\n      container.appendChild(paper.node);\n\n      // Set paper in DOM element so we have a trace for later\n      container.__chartistPaper = paper;\n    }\n\n    return paper;\n  };\n\n  // Convert data series into plain array\n  Chartist.getDataArray = function (data) {\n    var array = [];\n\n    for (var i = 0; i < data.series.length; i++) {\n      array[i] = data.series[i].data;\n    }\n\n    return array;\n  };\n\n  // Add missing values at the end of the arrays\n  Chartist.normalizeDataArray = function (dataArray, length) {\n    for (var i = 0; i < dataArray.length; i++) {\n      if (dataArray[i].length === length) {\n        continue;\n      }\n\n      for (var j = dataArray[i].length; j < length; j++) {\n        dataArray[i][j] = 0;\n      }\n    }\n\n    return dataArray;\n  };\n\n  Chartist.orderOfMagnitude = function (value) {\n    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  };\n\n  Chartist.projectLength = function (paper, length, bounds, options) {\n    var availableHeight = Chartist.getAvailableHeight(paper, options);\n    return (length / bounds.range * availableHeight);\n  };\n\n  Chartist.getAvailableHeight = function (paper, options) {\n    return Chartist.getHeight(paper.node) - (options.chartPadding * 2) - options.axisX.offset;\n  };\n\n  // Get highest and lowest value of data array\n  Chartist.getHighLow = function (dataArray) {\n    var i,\n      j,\n      highLow = {\n        high: Number.MIN_VALUE,\n        low: Number.MAX_VALUE\n      };\n\n    for (i = 0; i < dataArray.length; i++) {\n      for (j = 0; j < dataArray[i].length; j++) {\n        if (dataArray[i][j] > highLow.high) {\n          highLow.high = dataArray[i][j];\n        }\n\n        if (dataArray[i][j] < highLow.low) {\n          highLow.low = dataArray[i][j];\n        }\n      }\n    }\n\n    return highLow;\n  };\n\n  // Find the highest and lowest values in a two dimensional array and calculate scale based on order of magnitude\n  Chartist.getBounds = function (paper, dataArray, options, high, low) {\n    var i,\n      newMin,\n      newMax,\n      bounds = Chartist.getHighLow(dataArray);\n\n    // Overrides of high / low from settings\n    bounds.high = options.high || (options.high === 0 ? 0 : bounds.high);\n    bounds.low = options.low || (options.low === 0 ? 0 : bounds.low);\n\n    // Overrides of high / low from function call (highest priority)\n    bounds.high = high || (high === 0 ? 0 : bounds.high);\n    bounds.low = low || (low === 0 ? 0 : bounds.low);\n\n    bounds.valueRange = bounds.high - bounds.low;\n    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);\n    bounds.min = Math.floor(bounds.low / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.max = Math.ceil(bounds.high / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.range = bounds.max - bounds.min;\n    bounds.step = Math.pow(10, bounds.oom);\n    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);\n\n    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace\n    while (true) {\n      var length = Chartist.projectLength(paper, bounds.step / 2, bounds, options);\n      if (length >= options.axisY.scaleMinSpace) {\n        bounds.step /= 2;\n      } else {\n        break;\n      }\n    }\n\n    // Narrow min and max based on new step\n    newMin = bounds.min;\n    newMax = bounds.max;\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      if (i + bounds.step < bounds.low) {\n        newMin += bounds.step;\n      }\n\n      if (i - bounds.step > bounds.high) {\n        newMax -= bounds.step;\n      }\n    }\n    bounds.min = newMin;\n    bounds.max = newMax;\n    bounds.range = bounds.max - bounds.min;\n\n    bounds.values = [];\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      bounds.values.push(i);\n    }\n\n    return bounds;\n  };\n\n  Chartist.calculateLabelOffset = function (paper, data, labelClass, labelInterpolationFnc, offsetFnc) {\n    var offset = 0;\n    for (var i = 0; i < data.length; i++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolated = labelInterpolationFnc(data[i], i);\n      if (!interpolated && interpolated !== 0) {\n        continue;\n      }\n\n      var label = paper.text(0, 0, '' + interpolated);\n      label.node.setAttribute('class', labelClass);\n\n      // Check if this is the largest label and update offset\n      offset = Math.max(offset, offsetFnc(label.node));\n      // Remove label after offset Calculation\n      label.remove();\n    }\n\n    return offset;\n  };\n\n  // Used to iterate over array, interpolate using a interpolation function and executing callback (used for rendering)\n  Chartist.interpolateData = function (data, labelInterpolationFnc, callback) {\n    for (var index = 0; index < data.length; index++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolatedValue = labelInterpolationFnc(data[index], index);\n      if (!interpolatedValue && interpolatedValue !== 0) {\n        continue;\n      }\n\n      callback(data, index, interpolatedValue);\n    }\n  };\n\n  Chartist.polarToCartesian = function(centerX, centerY, radius, angleInDegrees) {\n    var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;\n\n    return {\n      x: centerX + (radius * Math.cos(angleInRadians)),\n      y: centerY + (radius * Math.sin(angleInRadians))\n    };\n  };\n\n  // Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right\n  Chartist.createChartRect = function (paper, options, xAxisOffset, yAxisOffset) {\n    return {\n      x1: options.chartPadding + yAxisOffset,\n      y1: (options.height || Chartist.getHeight(paper.node)) - options.chartPadding - xAxisOffset,\n      x2: (options.width || Chartist.getWidth(paper.node)) - options.chartPadding,\n      y2: options.chartPadding,\n      width: function () {\n        return this.x2 - this.x1;\n      },\n      height: function () {\n        return this.y1 - this.y2;\n      }\n    };\n  };\n\n  Chartist.createXAxis = function(paper, chartRect, data, grid, labels, options) {\n    // Create X-Axis\n    Chartist.each(data.labels, function (index, value) {\n      var interpolatedValue = options.axisX.labelInterpolationFnc(value, index),\n        pos = chartRect.x1 + chartRect.width() / data.labels.length * index;\n\n      // If interpolated value returns falsey (except 0) we don't draw the grid line\n      if(!interpolatedValue && interpolatedValue !== 0) {\n        return;\n      }\n\n      if (options.axisX.showGrid) {\n        var line = paper.line(pos, chartRect.y1, pos, chartRect.y2);\n        line.node.setAttribute('class', [options.classNames.grid, options.classNames.horizontal].join(' '));\n        grid.add(line);\n      }\n\n      if (options.axisX.showLabel) {\n        // Use config offset for setting labels of\n        var label = paper.text(pos + 2, 0, '' + interpolatedValue);\n        label.node.setAttribute('class', [options.classNames.label, options.classNames.horizontal].join(' '));\n\n        // TODO: should use 'alignment-baseline': 'hanging' but not supported in firefox. Instead using calculated height to offset y pos\n        label.attr({\n          y: chartRect.y1 + Chartist.getHeight(label.node) + options.axisX.offset\n        });\n\n        labels.add(label);\n      }\n    });\n  };\n\n  Chartist.createYAxis = function(paper, chartRect, bounds, grid, labels, offset, options) {\n    // Create Y-Axis\n    Chartist.each(bounds.values, function (index, value) {\n      var interpolatedValue = options.axisY.labelInterpolationFnc(value, index),\n        pos = chartRect.y1 - chartRect.height() / bounds.values.length * index;\n\n      // If interpolated value returns falsey (except 0) we don't draw the grid line\n      if(!interpolatedValue && interpolatedValue !== 0) {\n        return;\n      }\n\n      if (options.axisY.showGrid) {\n        var line = paper.line(chartRect.x1, pos, chartRect.x2, pos);\n        line.node.setAttribute('class', options.classNames.grid + ' ' + options.classNames.vertical);\n        grid.add(line);\n      }\n\n      if (options.axisY.showLabel) {\n        // Position later\n        //TODO: make padding of 2px configurable\n        //TODO: Check for refacoring\n        var label = paper.text(options.axisY.labelAlign === 'right' ? offset - options.axisY.offset + options.chartPadding : options.chartPadding,\n            pos - 2, '' + interpolatedValue);\n        label.node.setAttribute('class', options.classNames.label + ' ' + options.classNames.vertical);\n\n        // Set text-anchor based on alignment\n        label.attr({\n          'text-anchor': options.axisY.labelAlign === 'right' ? 'end' : 'start'\n        });\n\n        labels.add(label);\n      }\n    });\n  };\n\n  Chartist.projectPoint = function(chartRect, bounds, data, index) {\n    return {\n      x: chartRect.x1 + chartRect.width() / data.length * index,\n      y: chartRect.y1 - chartRect.height() * (data[index] - bounds.min) / (bounds.range + bounds.step)\n    };\n  };\n\n  // Provides options handling functionality with callback for options changes triggered by responsive options and media query matches\n  // TODO: With multiple media queries the handleMediaChange function is triggered too many times, only need one\n  Chartist.optionsProvider = function (defaultOptions, options, responsiveOptions, optionsChangedCallbackFnc) {\n    var baseOptions = Chartist.extend(Chartist.extend({}, defaultOptions), options),\n      currentOptions,\n      mediaQueryListeners = [],\n      i;\n\n    function applyOptions() {\n      currentOptions = Chartist.extend({}, baseOptions);\n\n      if (responsiveOptions) {\n        for (i = 0; i < responsiveOptions.length; i++) {\n          var mql = window.matchMedia(responsiveOptions[i][0]);\n          if (mql.matches) {\n            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);\n          }\n        }\n      }\n\n      optionsChangedCallbackFnc(currentOptions);\n      return currentOptions;\n    }\n\n    if (!window.matchMedia) {\n      throw 'window.matchMedia not found! Make sure you\\'re using a polyfill.';\n    } else if (responsiveOptions) {\n\n      for (i = 0; i < responsiveOptions.length; i++) {\n        var mql = window.matchMedia(responsiveOptions[i][0]);\n        mql.addListener(applyOptions);\n        mediaQueryListeners.push(mql);\n      }\n    }\n\n    return applyOptions();\n  };\n}(document, window));"]}