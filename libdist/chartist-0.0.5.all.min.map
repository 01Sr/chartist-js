{"version":3,"file":"chartist-0.0.5.all.min.js","sources":["../source/scripts/chartist.core.js","../source/scripts/chartist.line.js"],"names":["document","window","undefined","Chartist","version","noop","n","alphaNumerate","String","fromCharCode","extend","target","source","prop","filter","array","filterFnc","acceptedOnly","i","accepted","handler","accept","e","push","acceptOnly","length","returnValue","call","getHeight","svgElement","clientHeight","Math","round","getBBox","height","parentNode","getWidth","clientWidth","width","getDataArray","data","series","normalizeDataArray","dataArray","j","orderOfMagnitude","value","floor","log","abs","LN10","projectLength","paper","bounds","options","availableHeight","getAvailableHeight","range","node","chartPadding","axisX","offset","getBounds","newMin","newMax","low","Number","MAX_VALUE","high","MIN_VALUE","valueRange","oom","min","pow","max","ceil","step","numberOfSteps","axisY","scaleMinSpace","values","calculateLabelOffset","labelClass","labelInterpolationFnc","offsetFnc","interpolated","label","text","setAttribute","remove","interpolateData","callback","index","interpolatedValue","createChartRect","xAxisOffset","yAxisOffset","x1","y1","x2","y2","this","optionsProvider","defaultOptions","responsiveOptions","optionsChangedCallbackFnc","applyOptions","currentOptions","baseOptions","mql","matchMedia","matches","mediaQueryListeners","addListener","Line","query","createChart","createSeries","seriesGroup","projectPointFnc","point","p","path","x","y","lineSmooth","showPoint","line","classNames","append","showLine","snapPath","prepend","projectPoint","chartRect","seriesGroups","clear","showLabel","labels","horizontal","join","g","grid","pos","showGrid","add","attr","vertical","labelAlign","text-anchor","className","container","querySelector","Snap","appendChild","changedOptions","addEventListener","update"],"mappings":";;;;;CAAC,SAAUA,EAAUC,EAAQC,GAC3B,YAGA,IAAIC,GAAWF,EAAOE,SAAWF,EAAOE,YAExCA,GAASC,QAAU,QAGnBD,EAASE,KAAO,SAAUC,GACxB,MAAOA,IAITH,EAASI,cAAgB,SAAUD,GAEjC,MAAOE,QAAOC,aAAa,GAAKH,EAAI,KAItCH,EAASO,OAAS,SAAUC,EAAQC,GAClCD,EAASA,KACT,KAAK,GAAIE,KAAQD,GAEbD,EAAOE,GADmB,gBAAjBD,GAAOC,GACDV,EAASO,OAAOC,EAAOE,GAAOD,EAAOC,IAErCD,EAAOC,EAG1B,OAAOF,IAITR,EAASW,OAAS,SAAUC,EAAOC,GACjC,GACEC,GACAC,EAFEC,KAGFC,GACEC,OAAQ,SAAUC,GAChBH,EAASI,KAAKD,IAEhBE,WAAY,SAAUF,GACpBL,EAAeK,GAIrB,KAAKJ,EAAI,EAAGA,EAAIH,EAAMU,OAAQP,IAAK,CACjC,GAAIQ,GAAcV,EAAUW,KAAKP,EAASL,EAAMG,GAEhD,IAAID,IAAiBf,EACnB,MAAOe,EAGT,IAAIS,KAAgB,EAClB,MAAOP,GAIX,MAAOA,IAKThB,EAASyB,UAAY,SAAUC,GAC7B,MAAOA,GAAWC,cAAgBC,KAAKC,MAAMH,EAAWI,UAAUC,SAAWL,EAAWM,WAAWL,cAGrG3B,EAASiC,SAAW,SAAUP,GAC5B,MAAOA,GAAWQ,aAAeN,KAAKC,MAAMH,EAAWI,UAAUK,QAAUT,EAAWM,WAAWE,aAInGlC,EAASoC,aAAe,SAAUC,GAGhC,IAAK,GAFDzB,MAEKG,EAAI,EAAGA,EAAIsB,EAAKC,OAAOhB,OAAQP,IACtCH,EAAMG,GAAKsB,EAAKC,OAAOvB,GAAGsB,IAG5B,OAAOzB,IAITZ,EAASuC,mBAAqB,SAAUC,EAAWlB,GACjD,IAAK,GAAIP,GAAI,EAAGA,EAAIyB,EAAUlB,OAAQP,IACpC,GAAIyB,EAAUzB,GAAGO,SAAWA,EAI5B,IAAK,GAAImB,GAAID,EAAUzB,GAAGO,OAAYA,EAAJmB,EAAYA,IAC5CD,EAAUzB,GAAG0B,GAAK,CAItB,OAAOD,IAGTxC,EAAS0C,iBAAmB,SAAUC,GACpC,MAAOf,MAAKgB,MAAMhB,KAAKiB,IAAIjB,KAAKkB,IAAIH,IAAUf,KAAKmB,OAGrD/C,EAASgD,cAAgB,SAAUC,EAAO3B,EAAQ4B,EAAQC,GACxD,GAAIC,GAAkBpD,EAASqD,mBAAmBJ,EAAOE,EACzD,OAAQ7B,GAAS4B,EAAOI,MAAQF,GAGlCpD,EAASqD,mBAAqB,SAAUJ,EAAOE,GAC7C,MAAOnD,GAASyB,UAAUwB,EAAMM,MAAgC,EAAvBJ,EAAQK,aAAoBL,EAAQM,MAAMC,QAIrF1D,EAAS2D,UAAY,SAAUV,EAAOT,EAAWW,GAC/C,GAAIpC,GACF0B,EACAmB,EACAC,EACAX,GACEY,IAAKC,OAAOC,UACZC,KAAMF,OAAOG,UAGjB,KAAKnD,EAAI,EAAGA,EAAIyB,EAAUlB,OAAQP,IAChC,IAAK0B,EAAI,EAAGA,EAAID,EAAUzB,GAAGO,OAAQmB,IAC/BD,EAAUzB,GAAG0B,GAAKS,EAAOe,OAC3Bf,EAAOe,KAAOzB,EAAUzB,GAAG0B,IAGzBD,EAAUzB,GAAG0B,GAAKS,EAAOY,MAC3BZ,EAAOY,IAAMtB,EAAUzB,GAAG0B,GAchC,KATAS,EAAOiB,WAAajB,EAAOe,KAAOf,EAAOY,IACzCZ,EAAOkB,IAAMpE,EAAS0C,iBAAiBQ,EAAOiB,YAC9CjB,EAAOmB,IAAMzC,KAAKgB,MAAMM,EAAOY,IAAMlC,KAAK0C,IAAI,GAAIpB,EAAOkB,MAAQxC,KAAK0C,IAAI,GAAIpB,EAAOkB,KACrFlB,EAAOqB,IAAM3C,KAAK4C,KAAKtB,EAAOe,KAAOrC,KAAK0C,IAAI,GAAIpB,EAAOkB,MAAQxC,KAAK0C,IAAI,GAAIpB,EAAOkB,KACrFlB,EAAOI,MAAQJ,EAAOqB,IAAMrB,EAAOmB,IACnCnB,EAAOuB,KAAO7C,KAAK0C,IAAI,GAAIpB,EAAOkB,KAClClB,EAAOwB,cAAgB9C,KAAKC,MAAMqB,EAAOI,MAAQJ,EAAOuB,QAG3C,CACX,GAAInD,GAAStB,EAASgD,cAAcC,EAAOC,EAAOuB,KAAO,EAAGvB,EAAQC,EACpE,MAAI7B,GAAU6B,EAAQwB,MAAMC,eAG1B,KAFA1B,GAAOuB,MAAQ,EASnB,IAFAb,EAASV,EAAOmB,IAChBR,EAASX,EAAOqB,IACXxD,EAAImC,EAAOmB,IAAKtD,GAAKmC,EAAOqB,IAAKxD,GAAKmC,EAAOuB,KAC5C1D,EAAImC,EAAOuB,KAAOvB,EAAOY,MAC3BF,GAAUV,EAAOuB,MAGf1D,EAAImC,EAAOuB,KAAOvB,EAAOe,OAC3BJ,GAAUX,EAAOuB,KAQrB,KALAvB,EAAOmB,IAAMT,EACbV,EAAOqB,IAAMV,EACbX,EAAOI,MAAQJ,EAAOqB,IAAMrB,EAAOmB,IAEnCnB,EAAO2B,UACF9D,EAAImC,EAAOmB,IAAKtD,GAAKmC,EAAOqB,IAAKxD,GAAKmC,EAAOuB,KAChDvB,EAAO2B,OAAOzD,KAAKL,EAGrB,OAAOmC,IAGTlD,EAAS8E,qBAAuB,SAAU7B,EAAOZ,EAAM0C,EAAYC,EAAuBC,GAExF,IAAK,GADDvB,GAAS,EACJ3C,EAAI,EAAGA,EAAIsB,EAAKf,OAAQP,IAAK,CAEpC,GAAImE,GAAeF,EAAsB3C,EAAKtB,GAAIA,EAClD,IAAKmE,GAAiC,IAAjBA,EAArB,CAIA,GAAIC,GAAQlC,EAAMmC,KAAK,EAAG,EAAG,GAAKF,EAClCC,GAAM5B,KAAK8B,aAAa,QAASN,GAGjCrB,EAAS9B,KAAK2C,IAAIb,EAAQuB,EAAUE,EAAM5B,OAE1C4B,EAAMG,UAGR,MAAO5B,IAIT1D,EAASuF,gBAAkB,SAAUlD,EAAM2C,EAAuBQ,GAChE,IAAK,GAAIC,GAAQ,EAAGA,EAAQpD,EAAKf,OAAQmE,IAAS,CAEhD,GAAIC,GAAoBV,EAAsB3C,EAAKoD,GAAQA,IACtDC,GAA2C,IAAtBA,IAI1BF,EAASnD,EAAMoD,EAAOC,KAK1B1F,EAAS2F,gBAAkB,SAAU1C,EAAOE,EAASyC,EAAaC,GAChE,OACEC,GAAI3C,EAAQK,aAAeqC,EAC3BE,IAAK5C,EAAQpB,QAAU/B,EAASyB,UAAUwB,EAAMM,OAASJ,EAAQK,aAAeoC,EAChFI,IAAK7C,EAAQhB,OAASnC,EAASiC,SAASgB,EAAMM,OAASJ,EAAQK,aAC/DyC,GAAI9C,EAAQK,aACZrB,MAAO,WACL,MAAO+D,MAAKF,GAAKE,KAAKJ,IAExB/D,OAAQ,WACN,MAAOmE,MAAKH,GAAKG,KAAKD,MAO5BjG,EAASmG,gBAAkB,SAAUC,EAAgBjD,EAASkD,EAAmBC,GAM/E,QAASC,KAGP,GAFAC,EAAiBxG,EAASO,UAAWkG,GAEjCJ,EACF,IAAKtF,EAAI,EAAGA,EAAIsF,EAAkB/E,OAAQP,IAAK,CAC7C,GAAI2F,GAAM5G,EAAO6G,WAAWN,EAAkBtF,GAAG,GAC7C2F,GAAIE,UACNJ,EAAiBxG,EAASO,OAAOiG,EAAgBH,EAAkBtF,GAAG,KAM5E,MADAuF,GAA0BE,GACnBA,EAlBT,GACEA,GAEAzF,EAHE0F,EAAczG,EAASO,OAAOP,EAASO,UAAW6F,GAAiBjD,GAErE0D,IAmBF,KAAK/G,EAAO6G,WACV,KAAM,iEACD,IAAIN,EAET,IAAKtF,EAAI,EAAGA,EAAIsF,EAAkB/E,OAAQP,IAAK,CAC7C,GAAI2F,GAAM5G,EAAO6G,WAAWN,EAAkBtF,GAAG,GACjD2F,GAAII,YAAYP,GAChBM,EAAoBzF,KAAKsF,GAI7B,MAAOH,OAET1G,SAAUC,QCrQX,SAAUD,EAAUC,EAAQE,EAAUD,GACrC,YACAC,GAAS+G,KAAO/G,EAAS+G,MAAQ,SAAUC,EAAO3E,EAAMc,EAASkD,GAuC/D,QAASY,GAAY9D,GAyFnB,QAAS+D,GAAa7E,EAAM8E,EAAaC,GACvC,GAEEC,GAFEC,EAAIF,EAAgB/E,EAAM,GAC5BkF,EAAO,IAAMD,EAAEE,EAAI,IAAMF,EAAEG,EAAI,KAAOtE,EAAQuE,WAAa,IAAM,IAI/DvE,GAAQwE,YACVN,EAAQpE,EAAM2E,KAAKN,EAAEE,EAAGF,EAAEG,EAAGH,EAAEE,EAAGF,EAAEG,GACpCJ,EAAM9D,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAWR,OACpDF,EAAYW,OAAOT,GAIrB,KAAK,GAAItG,GAAI,EAAGA,EAAIsB,EAAKf,OAAQP,IAC/BuG,EAAIF,EAAgB/E,EAAMtB,GAC1BwG,GAAQ,IAAMD,EAAEE,EAAI,IAAMF,EAAEG,EAGxBtE,EAAQwE,YACVN,EAAQpE,EAAM2E,KAAKN,EAAEE,EAAGF,EAAEG,EAAGH,EAAEE,EAAGF,EAAEG,GACpCJ,EAAM9D,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAWR,OACpDF,EAAYW,OAAOT,GAIvB,IAAIlE,EAAQ4E,SAAU,CACpB,GAAIC,GAAW/E,EAAMsE,KAAKA,EAC1BS,GAASzE,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAWD,MACvDT,EAAYc,QAAQD,IAIxB,QAASE,GAAa7F,EAAMoD,GAC1B,OACE+B,EAAGW,EAAUrC,GAAKqC,EAAUhG,QAAUE,EAAKf,OAASmE,EACpDgC,EAAGU,EAAUpC,GAAK1D,EAAKoD,GAASvC,EAAOI,MAAQ6E,EAAUpG,SAAYmB,EAAOmB,IAAMnB,EAAOI,MAAQ6E,EAAUpG,UA3H/G,GAAI6D,GACFC,EAEA3C,EADAkF,IAIFnF,GAAMoF,QAGNnF,EAASlD,EAAS2D,UAAUV,EAAOT,EAAWW,GAE9CyC,EAAczC,EAAQM,MAAMC,OACxBP,EAAQM,MAAM6E,YAChB1C,GAAe5F,EAAS8E,qBACtB7B,EACAZ,EAAKkG,QACJpF,EAAQ0E,WAAW1C,MAAOhC,EAAQ0E,WAAWW,YAAYC,KAAK,KAC/DtF,EAAQM,MAAMuB,sBACdhF,EAASyB,YAIboE,EAAc1C,EAAQwB,MAAMjB,OACxBP,EAAQwB,MAAM2D,YAChBzC,GAAe7F,EAAS8E,qBACtB7B,EACAC,EAAO2B,QACN1B,EAAQ0E,WAAW1C,MAAOhC,EAAQ0E,WAAWW,YAAYC,KAAK,KAC/DtF,EAAQwB,MAAMK,sBACdhF,EAASiC,UAIb,IAAIkG,GAAYnI,EAAS2F,gBAAgB1C,EAAOE,EAASyC,EAAaC,GAElE0C,EAAStF,EAAMyF,IACjBC,EAAO1F,EAAMyF,GA6Ff,KA1FA1I,EAASuF,gBAAgBlD,EAAKkG,OAAQpF,EAAQM,MAAMuB,sBAAuB,SAAU3C,EAAMoD,EAAOC,GAChG,GAAIkD,GAAMT,EAAUrC,GAAKqC,EAAUhG,QAAUE,EAAKf,OAASmE,CAE3D,IAAItC,EAAQM,MAAMoF,SAAU,CAC1B,GAAIjB,GAAO3E,EAAM2E,KAAKgB,EAAKT,EAAUpC,GAAI6C,EAAKT,EAAUlC,GACxD2B,GAAKrE,KAAK8B,aAAa,SAAUlC,EAAQ0E,WAAWc,KAAMxF,EAAQ0E,WAAWW,YAAYC,KAAK,MAC9FE,EAAKG,IAAIlB,GAGX,GAAIzE,EAAQM,MAAM6E,UAAW,CAE3B,GAAInD,GAAQlC,EAAMmC,KAAKwD,EAAM,EAAG,EAAG,GAAKlD,EACxCP,GAAM5B,KAAK8B,aAAa,SAAUlC,EAAQ0E,WAAW1C,MAAOhC,EAAQ0E,WAAWW,YAAYC,KAAK,MAGhGtD,EAAM4D,MACJtB,EAAGU,EAAUpC,GAAK/F,EAASyB,UAAU0D,EAAM5B,MAAQJ,EAAQM,MAAMC,SAGnE6E,EAAOO,IAAI3D,MAKfnF,EAASuF,gBAAgBrC,EAAO2B,OAAQ1B,EAAQwB,MAAMK,sBAAuB,SAAU3C,EAAMoD,EAAOC,GAClG,GAAIkD,GAAMT,EAAUpC,GAAKoC,EAAUpG,SAAWM,EAAKf,OAASmE,CAE5D,IAAItC,EAAQwB,MAAMkE,SAAU,CAC1B,GAAIjB,GAAO3E,EAAM2E,KAAKO,EAAUrC,GAAI8C,EAAKT,EAAUnC,GAAI4C,EACvDhB,GAAKrE,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAWc,KAAO,IAAMxF,EAAQ0E,WAAWmB,UACnFL,EAAKG,IAAIlB,GAGX,GAAIzE,EAAQwB,MAAM2D,UAAW,CAG3B,GAAInD,GAAQlC,EAAMmC,KAAkC,UAA7BjC,EAAQwB,MAAMsE,WAAyBpD,EAAc1C,EAAQwB,MAAMjB,OAASP,EAAQK,aAAeL,EAAQK,aAChIoF,EAAM,EAAG,GAAKlD,EAChBP,GAAM5B,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAW1C,MAAQ,IAAMhC,EAAQ0E,WAAWmB,UAGrF7D,EAAM4D,MACJG,cAA4C,UAA7B/F,EAAQwB,MAAMsE,WAAyB,MAAQ,UAGhEV,EAAOO,IAAI3D,MA6CVpE,EAAI,EAAGA,EAAIsB,EAAKC,OAAOhB,OAAQP,IAClCqH,EAAarH,GAAKkC,EAAMyF,IAExBN,EAAarH,GAAGwC,KAAK8B,aAAa,QAASlC,EAAQ0E,WAAWvF,OAAS,KACpED,EAAKC,OAAOvB,GAAGoI,WAAahG,EAAQ0E,WAAWvF,OAAS,IAAMtC,EAASI,cAAcW,KAExFmG,EAAa7E,EAAKC,OAAOvB,GAAGsB,KAAM+F,EAAarH,GAAImH,GAEnDjF,EAAM6F,IAAIV,EAAarH,IA/K3B,GA+BEyF,GAEAvD,EAEAlC,EAnCEqF,GACA3C,OACEC,OAAQ,EACR4E,WAAW,EACXO,UAAU,EACV7D,sBAAuBhF,EAASE,MAElCyE,OACEjB,OAAQ,EACR4E,WAAW,EACXO,UAAU,EACVI,WAAY,QACZjE,sBAAuBhF,EAASE,KAChC0E,cAAe,IAEjBzC,MAAOpC,EACPgC,OAAQhC,EACRgI,UAAU,EACVJ,WAAW,EACXD,YAAY,EACZlE,aAAc,EACdqE,YACE1C,MAAO,WACP7C,OAAQ,YACRsF,KAAM,UACNP,MAAO,WACPsB,KAAM,UACNK,SAAU,cACVR,WAAY,kBAIhBY,EAAYvJ,EAASwJ,cAAcrC,GAEnCxE,EAAYxC,EAASuC,mBAAmBvC,EAASoC,aAAaC,GAAOA,EAAKkG,OAAOjH,OAmJnF,KAAK8H,EACH,KAAM,iCAAmCpC,EAAQ,aAInD,IADA/D,EAAQqG,KAAKnG,EAAQhB,OAAS,OAAQgB,EAAQpB,QAAU,SACnDkB,EACH,KAAM,gCAoBR,OAlBAmG,GAAUG,YAAYtG,EAAMM,MAI5BiD,EAAiBxG,EAASmG,gBAAgBC,EAAgBjD,EAASkD,EAAmB,SAAUmD,GAC9FhD,EAAiBgD,EACjBvC,EAAYT,KAOd1G,EAAO2J,iBAAiB,SAAU,WAChCxC,EAAYT,MAKZvG,QAASD,EAASC,QAClByJ,OAAQ,WACNzC,EAAYT,OAIlB3G,SAAUC,OAAQA,OAAOE","sourcesContent":["(function (document, window, undefined) {\n  'use strict';\n\n  // Export chartist namespace\n  var Chartist = window.Chartist = window.Chartist || {};\n\n  Chartist.version = '0.0.3';\n\n  // Helps to simplify functional style code\n  Chartist.noop = function (n) {\n    return n;\n  };\n\n  // Generates a-z from number\n  Chartist.alphaNumerate = function (n) {\n    // Limit to a-z\n    return String.fromCharCode(97 + n % 26);\n  };\n\n  // Simple recursive object extend\n  Chartist.extend = function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      if (typeof source[prop] === 'object') {\n        target[prop] = Chartist.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  };\n\n  // Filter an array\n  Chartist.filter = function (array, filterFnc) {\n    var accepted = [],\n      acceptedOnly,\n      i,\n      handler = {\n        accept: function (e) {\n          accepted.push(e);\n        },\n        acceptOnly: function (e) {\n          acceptedOnly = e;\n        }\n      };\n\n    for (i = 0; i < array.length; i++) {\n      var returnValue = filterFnc.call(handler, array[i]);\n\n      if (acceptedOnly !== undefined) {\n        return acceptedOnly;\n      }\n\n      if (returnValue === false) {\n        return accepted;\n      }\n    }\n\n    return accepted;\n  };\n\n  // Get element height / width with fallback to svg BoundingBox or parent container dimensions\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=530985\n  Chartist.getHeight = function (svgElement) {\n    return svgElement.clientHeight || Math.round(svgElement.getBBox().height) || svgElement.parentNode.clientHeight;\n  };\n\n  Chartist.getWidth = function (svgElement) {\n    return svgElement.clientWidth || Math.round(svgElement.getBBox().width) || svgElement.parentNode.clientWidth;\n  };\n\n  // Convert data series into plain array\n  Chartist.getDataArray = function (data) {\n    var array = [];\n\n    for (var i = 0; i < data.series.length; i++) {\n      array[i] = data.series[i].data;\n    }\n\n    return array;\n  };\n\n  // Add missing values at the end of the arrays\n  Chartist.normalizeDataArray = function (dataArray, length) {\n    for (var i = 0; i < dataArray.length; i++) {\n      if (dataArray[i].length === length) {\n        continue;\n      }\n\n      for (var j = dataArray[i].length; j < length; j++) {\n        dataArray[i][j] = 0;\n      }\n    }\n\n    return dataArray;\n  };\n\n  Chartist.orderOfMagnitude = function (value) {\n    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  };\n\n  Chartist.projectLength = function (paper, length, bounds, options) {\n    var availableHeight = Chartist.getAvailableHeight(paper, options);\n    return (length / bounds.range * availableHeight);\n  };\n\n  Chartist.getAvailableHeight = function (paper, options) {\n    return Chartist.getHeight(paper.node) - (options.chartPadding * 2) - options.axisX.offset;\n  };\n\n  // Find the highest and lowest values in a two dimensional array and calculate scale based on order of magnitude\n  Chartist.getBounds = function (paper, dataArray, options) {\n    var i,\n      j,\n      newMin,\n      newMax,\n      bounds = {\n        low: Number.MAX_VALUE,\n        high: Number.MIN_VALUE\n      };\n\n    for (i = 0; i < dataArray.length; i++) {\n      for (j = 0; j < dataArray[i].length; j++) {\n        if (dataArray[i][j] > bounds.high) {\n          bounds.high = dataArray[i][j];\n        }\n\n        if (dataArray[i][j] < bounds.low) {\n          bounds.low = dataArray[i][j];\n        }\n      }\n    }\n\n    bounds.valueRange = bounds.high - bounds.low;\n    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);\n    bounds.min = Math.floor(bounds.low / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.max = Math.ceil(bounds.high / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.range = bounds.max - bounds.min;\n    bounds.step = Math.pow(10, bounds.oom);\n    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);\n\n    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace\n    while (true) {\n      var length = Chartist.projectLength(paper, bounds.step / 2, bounds, options);\n      if (length >= options.axisY.scaleMinSpace) {\n        bounds.step /= 2;\n      } else {\n        break;\n      }\n    }\n\n    // Narrow min and max based on new step\n    newMin = bounds.min;\n    newMax = bounds.max;\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      if (i + bounds.step < bounds.low) {\n        newMin += bounds.step;\n      }\n\n      if (i - bounds.step > bounds.high) {\n        newMax -= bounds.step;\n      }\n    }\n    bounds.min = newMin;\n    bounds.max = newMax;\n    bounds.range = bounds.max - bounds.min;\n\n    bounds.values = [];\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      bounds.values.push(i);\n    }\n\n    return bounds;\n  };\n\n  Chartist.calculateLabelOffset = function (paper, data, labelClass, labelInterpolationFnc, offsetFnc) {\n    var offset = 0;\n    for (var i = 0; i < data.length; i++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolated = labelInterpolationFnc(data[i], i);\n      if (!interpolated && interpolated !== 0) {\n        continue;\n      }\n\n      var label = paper.text(0, 0, '' + interpolated);\n      label.node.setAttribute('class', labelClass);\n\n      // Check if this is the largest label and update offset\n      offset = Math.max(offset, offsetFnc(label.node));\n      // Remove label after offset Calculation\n      label.remove();\n    }\n\n    return offset;\n  };\n\n  // Used to iterate over array, interpolate using a interpolation function and executing callback (used for rendering)\n  Chartist.interpolateData = function (data, labelInterpolationFnc, callback) {\n    for (var index = 0; index < data.length; index++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolatedValue = labelInterpolationFnc(data[index], index);\n      if (!interpolatedValue && interpolatedValue !== 0) {\n        continue;\n      }\n\n      callback(data, index, interpolatedValue);\n    }\n  };\n\n  // Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right\n  Chartist.createChartRect = function (paper, options, xAxisOffset, yAxisOffset) {\n    return {\n      x1: options.chartPadding + yAxisOffset,\n      y1: (options.height || Chartist.getHeight(paper.node)) - options.chartPadding - xAxisOffset,\n      x2: (options.width || Chartist.getWidth(paper.node)) - options.chartPadding,\n      y2: options.chartPadding,\n      width: function () {\n        return this.x2 - this.x1;\n      },\n      height: function () {\n        return this.y1 - this.y2;\n      }\n    };\n  };\n\n  // Provides options handling functionality with callback for options changes triggered by responsive options and media query matches\n  // TODO: With multiple media queries the handleMediaChange function is triggered too many times, only need one\n  Chartist.optionsProvider = function (defaultOptions, options, responsiveOptions, optionsChangedCallbackFnc) {\n    var baseOptions = Chartist.extend(Chartist.extend({}, defaultOptions), options),\n      currentOptions,\n      mediaQueryListeners = [],\n      i;\n\n    function applyOptions() {\n      currentOptions = Chartist.extend({}, baseOptions);\n\n      if (responsiveOptions) {\n        for (i = 0; i < responsiveOptions.length; i++) {\n          var mql = window.matchMedia(responsiveOptions[i][0]);\n          if (mql.matches) {\n            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);\n          }\n        }\n      }\n\n      optionsChangedCallbackFnc(currentOptions);\n      return currentOptions;\n    }\n\n    if (!window.matchMedia) {\n      throw 'window.matchMedia not found! Make sure you\\'re using a polyfill.';\n    } else if (responsiveOptions) {\n\n      for (i = 0; i < responsiveOptions.length; i++) {\n        var mql = window.matchMedia(responsiveOptions[i][0]);\n        mql.addListener(applyOptions);\n        mediaQueryListeners.push(mql);\n      }\n    }\n\n    return applyOptions();\n  };\n}(document, window));","// Chartist line chart\n(function (document, window, Chartist, undefined) {\n  'use strict';\n  Chartist.Line = Chartist.Line || function (query, data, options, responsiveOptions) {\n\n    var defaultOptions = {\n        axisX: {\n          offset: 0,\n          showLabel: true,\n          showGrid: true,\n          labelInterpolationFnc: Chartist.noop\n        },\n        axisY: {\n          offset: 5,\n          showLabel: true,\n          showGrid: true,\n          labelAlign: 'right',\n          labelInterpolationFnc: Chartist.noop,\n          scaleMinSpace: 20\n        },\n        width: undefined,\n        height: undefined,\n        showLine: true,\n        showPoint: true,\n        lineSmooth: true,\n        chartPadding: 5,\n        classNames: {\n          label: 'ct-label',\n          series: 'ct-series',\n          line: 'ct-line',\n          point: 'ct-point',\n          grid: 'ct-grid',\n          vertical: 'ct-vertical',\n          horizontal: 'ct-horizontal'\n        }\n      },\n      currentOptions,\n      container = document.querySelector(query),\n      paper,\n      dataArray = Chartist.normalizeDataArray(Chartist.getDataArray(data), data.labels.length),\n      i;\n\n    function createChart(options) {\n      var xAxisOffset,\n        yAxisOffset,\n        seriesGroups = [],\n        bounds;\n\n      // Clear the stage\n      paper.clear();\n\n      // initialize bounds\n      bounds = Chartist.getBounds(paper, dataArray, options);\n\n      xAxisOffset = options.axisX.offset;\n      if (options.axisX.showLabel) {\n        xAxisOffset += Chartist.calculateLabelOffset(\n          paper,\n          data.labels,\n          [options.classNames.label, options.classNames.horizontal].join(' '),\n          options.axisX.labelInterpolationFnc,\n          Chartist.getHeight\n        );\n      }\n\n      yAxisOffset = options.axisY.offset;\n      if (options.axisY.showLabel) {\n        yAxisOffset += Chartist.calculateLabelOffset(\n          paper,\n          bounds.values,\n          [options.classNames.label, options.classNames.horizontal].join(' '),\n          options.axisY.labelInterpolationFnc,\n          Chartist.getWidth\n        );\n      }\n\n      var chartRect = Chartist.createChartRect(paper, options, xAxisOffset, yAxisOffset);\n      // Start drawing\n      var labels = paper.g(),\n        grid = paper.g();\n\n      // Create X-Axis\n      Chartist.interpolateData(data.labels, options.axisX.labelInterpolationFnc, function (data, index, interpolatedValue) {\n        var pos = chartRect.x1 + chartRect.width() / data.length * index;\n\n        if (options.axisX.showGrid) {\n          var line = paper.line(pos, chartRect.y1, pos, chartRect.y2);\n          line.node.setAttribute('class', [options.classNames.grid, options.classNames.horizontal].join(' '));\n          grid.add(line);\n        }\n\n        if (options.axisX.showLabel) {\n          // Use config offset for setting labels of\n          var label = paper.text(pos + 2, 0, '' + interpolatedValue);\n          label.node.setAttribute('class', [options.classNames.label, options.classNames.horizontal].join(' '));\n\n          // TODO: should use 'alignment-baseline': 'hanging' but not supported in firefox. Instead using calculated height to offset y pos\n          label.attr({\n            y: chartRect.y1 + Chartist.getHeight(label.node) + options.axisX.offset\n          });\n\n          labels.add(label);\n        }\n      });\n\n      // Create Y-Axis\n      Chartist.interpolateData(bounds.values, options.axisY.labelInterpolationFnc, function (data, index, interpolatedValue) {\n        var pos = chartRect.y1 - chartRect.height() / data.length * index;\n\n        if (options.axisY.showGrid) {\n          var line = paper.line(chartRect.x1, pos, chartRect.x2, pos);\n          line.node.setAttribute('class', options.classNames.grid + ' ' + options.classNames.vertical);\n          grid.add(line);\n        }\n\n        if (options.axisY.showLabel) {\n          // Position later\n          //TODO: make padding of 2px configurable\n          var label = paper.text(options.axisY.labelAlign === 'right' ? yAxisOffset - options.axisY.offset + options.chartPadding : options.chartPadding,\n            pos - 2, '' + interpolatedValue);\n          label.node.setAttribute('class', options.classNames.label + ' ' + options.classNames.vertical);\n\n          // Set text-anchor based on alignment\n          label.attr({\n            'text-anchor': options.axisY.labelAlign === 'right' ? 'end' : 'start'\n          });\n\n          labels.add(label);\n        }\n      });\n\n      function createSeries(data, seriesGroup, projectPointFnc) {\n        var p = projectPointFnc(data, 0),\n          path = 'M' + p.x + ',' + p.y + ' ' + (options.lineSmooth ? 'R' : 'L'),\n          point;\n\n        // First dot we need to add before loop\n        if (options.showPoint) {\n          point = paper.line(p.x, p.y, p.x, p.y);\n          point.node.setAttribute('class', options.classNames.point);\n          seriesGroup.append(point);\n        }\n\n        // First point is created, continue with rest\n        for (var i = 1; i < data.length; i++) {\n          p = projectPointFnc(data, i);\n          path += ' ' + p.x + ',' + p.y;\n\n          //If we should show points we need to create them now to avoid secondary loop\n          if (options.showPoint) {\n            point = paper.line(p.x, p.y, p.x, p.y);\n            point.node.setAttribute('class', options.classNames.point);\n            seriesGroup.append(point);\n          }\n        }\n\n        if (options.showLine) {\n          var snapPath = paper.path(path);\n          snapPath.node.setAttribute('class', options.classNames.line);\n          seriesGroup.prepend(snapPath);\n        }\n      }\n\n      function projectPoint(data, index) {\n        return {\n          x: chartRect.x1 + chartRect.width() / data.length * index,\n          y: chartRect.y1 - data[index] / bounds.range * chartRect.height() + (bounds.min / bounds.range * chartRect.height())\n        };\n      }\n\n      // Draw the series\n      // initialize series groups\n      for (i = 0; i < data.series.length; i++) {\n        seriesGroups[i] = paper.g();\n        // Use series class from series data or if not set generate one\n        seriesGroups[i].node.setAttribute('class', options.classNames.series + ' ' +\n          (data.series[i].className || options.classNames.series + '-' + Chartist.alphaNumerate(i)));\n\n        createSeries(data.series[i].data, seriesGroups[i], projectPoint);\n\n        paper.add(seriesGroups[i]);\n      }\n    }\n\n\n    // Do important checks and throw if necessary\n    if (!container) {\n      throw 'Container node with selector \"' + query + '\" not found';\n    }\n\n    paper = Snap(options.width || '100%', options.height || '100%');\n    if (!paper) {\n      throw 'Could not instantiate Snap.js!';\n    }\n    container.appendChild(paper.node);\n\n    // Obtain current options based on matching media queries (if responsive options are given)\n    // This will also register a listener that is re-creating the chart based on media changes\n    currentOptions = Chartist.optionsProvider(defaultOptions, options, responsiveOptions, function (changedOptions) {\n      currentOptions = changedOptions;\n      createChart(currentOptions);\n    });\n\n    // TODO: Currently we need to re-draw the chart on window resize. This is usually very bad and will affect performance.\n    // This is done because we can't work with relative coordinates when drawing the chart because SVG Path does not\n    // work with relative positions yet. We need to check if we can do a viewBox hack to switch to percentage.\n    // See http://mozilla.6506.n7.nabble.com/Specyfing-paths-with-percentages-unit-td247474.html\n    window.addEventListener('resize', function () {\n      createChart(currentOptions);\n    });\n\n    // Public members\n    return {\n      version: Chartist.version,\n      update: function () {\n        createChart(currentOptions);\n      }\n    };\n  };\n}(document, window, window.Chartist));"]}