{"version":3,"file":"chartist-0.0.5.core.min.js","sources":["../source/scripts/chartist.core.js"],"names":["document","window","undefined","Chartist","version","noop","n","alphaNumerate","String","fromCharCode","extend","target","source","prop","filter","array","filterFnc","acceptedOnly","i","accepted","handler","accept","e","push","acceptOnly","length","returnValue","call","getHeight","svgElement","clientHeight","Math","round","getBBox","height","parentNode","getWidth","clientWidth","width","getDataArray","data","series","normalizeDataArray","dataArray","j","orderOfMagnitude","value","floor","log","abs","LN10","projectLength","paper","bounds","options","availableHeight","getAvailableHeight","range","node","chartPadding","axisX","offset","getBounds","newMin","newMax","low","Number","MAX_VALUE","high","MIN_VALUE","valueRange","oom","min","pow","max","ceil","step","numberOfSteps","axisY","scaleMinSpace","values","calculateLabelOffset","labelClass","labelInterpolationFnc","offsetFnc","interpolated","label","text","setAttribute","remove","interpolateData","callback","index","interpolatedValue","createChartRect","xAxisOffset","yAxisOffset","x1","y1","x2","y2","this","optionsProvider","defaultOptions","responsiveOptions","optionsChangedCallbackFnc","applyOptions","currentOptions","baseOptions","mql","matchMedia","matches","mediaQueryListeners","addListener"],"mappings":"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","sourcesContent":["(function (document, window, undefined) {\n  'use strict';\n\n  // Export chartist namespace\n  var Chartist = window.Chartist = window.Chartist || {};\n\n  Chartist.version = '0.0.3';\n\n  // Helps to simplify functional style code\n  Chartist.noop = function (n) {\n    return n;\n  };\n\n  // Generates a-z from number\n  Chartist.alphaNumerate = function (n) {\n    // Limit to a-z\n    return String.fromCharCode(97 + n % 26);\n  };\n\n  // Simple recursive object extend\n  Chartist.extend = function (target, source) {\n    target = target || {};\n    for (var prop in source) {\n      if (typeof source[prop] === 'object') {\n        target[prop] = Chartist.extend(target[prop], source[prop]);\n      } else {\n        target[prop] = source[prop];\n      }\n    }\n    return target;\n  };\n\n  // Filter an array\n  Chartist.filter = function (array, filterFnc) {\n    var accepted = [],\n      acceptedOnly,\n      i,\n      handler = {\n        accept: function (e) {\n          accepted.push(e);\n        },\n        acceptOnly: function (e) {\n          acceptedOnly = e;\n        }\n      };\n\n    for (i = 0; i < array.length; i++) {\n      var returnValue = filterFnc.call(handler, array[i]);\n\n      if (acceptedOnly !== undefined) {\n        return acceptedOnly;\n      }\n\n      if (returnValue === false) {\n        return accepted;\n      }\n    }\n\n    return accepted;\n  };\n\n  // Get element height / width with fallback to svg BoundingBox or parent container dimensions\n  // See https://bugzilla.mozilla.org/show_bug.cgi?id=530985\n  Chartist.getHeight = function (svgElement) {\n    return svgElement.clientHeight || Math.round(svgElement.getBBox().height) || svgElement.parentNode.clientHeight;\n  };\n\n  Chartist.getWidth = function (svgElement) {\n    return svgElement.clientWidth || Math.round(svgElement.getBBox().width) || svgElement.parentNode.clientWidth;\n  };\n\n  // Convert data series into plain array\n  Chartist.getDataArray = function (data) {\n    var array = [];\n\n    for (var i = 0; i < data.series.length; i++) {\n      array[i] = data.series[i].data;\n    }\n\n    return array;\n  };\n\n  // Add missing values at the end of the arrays\n  Chartist.normalizeDataArray = function (dataArray, length) {\n    for (var i = 0; i < dataArray.length; i++) {\n      if (dataArray[i].length === length) {\n        continue;\n      }\n\n      for (var j = dataArray[i].length; j < length; j++) {\n        dataArray[i][j] = 0;\n      }\n    }\n\n    return dataArray;\n  };\n\n  Chartist.orderOfMagnitude = function (value) {\n    return Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  };\n\n  Chartist.projectLength = function (paper, length, bounds, options) {\n    var availableHeight = Chartist.getAvailableHeight(paper, options);\n    return (length / bounds.range * availableHeight);\n  };\n\n  Chartist.getAvailableHeight = function (paper, options) {\n    return Chartist.getHeight(paper.node) - (options.chartPadding * 2) - options.axisX.offset;\n  };\n\n  // Find the highest and lowest values in a two dimensional array and calculate scale based on order of magnitude\n  Chartist.getBounds = function (paper, dataArray, options) {\n    var i,\n      j,\n      newMin,\n      newMax,\n      bounds = {\n        low: Number.MAX_VALUE,\n        high: Number.MIN_VALUE\n      };\n\n    for (i = 0; i < dataArray.length; i++) {\n      for (j = 0; j < dataArray[i].length; j++) {\n        if (dataArray[i][j] > bounds.high) {\n          bounds.high = dataArray[i][j];\n        }\n\n        if (dataArray[i][j] < bounds.low) {\n          bounds.low = dataArray[i][j];\n        }\n      }\n    }\n\n    bounds.valueRange = bounds.high - bounds.low;\n    bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);\n    bounds.min = Math.floor(bounds.low / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.max = Math.ceil(bounds.high / Math.pow(10, bounds.oom)) * Math.pow(10, bounds.oom);\n    bounds.range = bounds.max - bounds.min;\n    bounds.step = Math.pow(10, bounds.oom);\n    bounds.numberOfSteps = Math.round(bounds.range / bounds.step);\n\n    // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace\n    while (true) {\n      var length = Chartist.projectLength(paper, bounds.step / 2, bounds, options);\n      if (length >= options.axisY.scaleMinSpace) {\n        bounds.step /= 2;\n      } else {\n        break;\n      }\n    }\n\n    // Narrow min and max based on new step\n    newMin = bounds.min;\n    newMax = bounds.max;\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      if (i + bounds.step < bounds.low) {\n        newMin += bounds.step;\n      }\n\n      if (i - bounds.step > bounds.high) {\n        newMax -= bounds.step;\n      }\n    }\n    bounds.min = newMin;\n    bounds.max = newMax;\n    bounds.range = bounds.max - bounds.min;\n\n    bounds.values = [];\n    for (i = bounds.min; i <= bounds.max; i += bounds.step) {\n      bounds.values.push(i);\n    }\n\n    return bounds;\n  };\n\n  Chartist.calculateLabelOffset = function (paper, data, labelClass, labelInterpolationFnc, offsetFnc) {\n    var offset = 0;\n    for (var i = 0; i < data.length; i++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolated = labelInterpolationFnc(data[i], i);\n      if (!interpolated && interpolated !== 0) {\n        continue;\n      }\n\n      var label = paper.text(0, 0, '' + interpolated);\n      label.node.setAttribute('class', labelClass);\n\n      // Check if this is the largest label and update offset\n      offset = Math.max(offset, offsetFnc(label.node));\n      // Remove label after offset Calculation\n      label.remove();\n    }\n\n    return offset;\n  };\n\n  // Used to iterate over array, interpolate using a interpolation function and executing callback (used for rendering)\n  Chartist.interpolateData = function (data, labelInterpolationFnc, callback) {\n    for (var index = 0; index < data.length; index++) {\n      // If interpolation function returns falsy value we skipp this label\n      var interpolatedValue = labelInterpolationFnc(data[index], index);\n      if (!interpolatedValue && interpolatedValue !== 0) {\n        continue;\n      }\n\n      callback(data, index, interpolatedValue);\n    }\n  };\n\n  // Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right\n  Chartist.createChartRect = function (paper, options, xAxisOffset, yAxisOffset) {\n    return {\n      x1: options.chartPadding + yAxisOffset,\n      y1: (options.height || Chartist.getHeight(paper.node)) - options.chartPadding - xAxisOffset,\n      x2: (options.width || Chartist.getWidth(paper.node)) - options.chartPadding,\n      y2: options.chartPadding,\n      width: function () {\n        return this.x2 - this.x1;\n      },\n      height: function () {\n        return this.y1 - this.y2;\n      }\n    };\n  };\n\n  // Provides options handling functionality with callback for options changes triggered by responsive options and media query matches\n  // TODO: With multiple media queries the handleMediaChange function is triggered too many times, only need one\n  Chartist.optionsProvider = function (defaultOptions, options, responsiveOptions, optionsChangedCallbackFnc) {\n    var baseOptions = Chartist.extend(Chartist.extend({}, defaultOptions), options),\n      currentOptions,\n      mediaQueryListeners = [],\n      i;\n\n    function applyOptions() {\n      currentOptions = Chartist.extend({}, baseOptions);\n\n      if (responsiveOptions) {\n        for (i = 0; i < responsiveOptions.length; i++) {\n          var mql = window.matchMedia(responsiveOptions[i][0]);\n          if (mql.matches) {\n            currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);\n          }\n        }\n      }\n\n      optionsChangedCallbackFnc(currentOptions);\n      return currentOptions;\n    }\n\n    if (!window.matchMedia) {\n      throw 'window.matchMedia not found! Make sure you\\'re using a polyfill.';\n    } else if (responsiveOptions) {\n\n      for (i = 0; i < responsiveOptions.length; i++) {\n        var mql = window.matchMedia(responsiveOptions[i][0]);\n        mql.addListener(applyOptions);\n        mediaQueryListeners.push(mql);\n      }\n    }\n\n    return applyOptions();\n  };\n}(document, window));"]}